{
    "study_materials": [
        {
            "id": 1755621088723,
            "topic": "python",
            "content": "## Python Study Notes: A Comprehensive Overview\n\n**I. Outline:**\n\nA. Introduction to Python\nB. Data Types & Structures\nC. Control Flow\nD. Functions\nE. Object-Oriented Programming (OOP)\nF. Modules and Packages\nG. Exception Handling\nH. File I/O\nI. Common Pitfalls & Debugging\n\n\n**II. Key Concepts & Concise Explanations:**\n\n**A. Introduction to Python:**\n\n* **Interpreted Language:** Python code is executed line by line, without the need for prior compilation.\n* **Dynamically Typed:** Variable types are checked during runtime, not during compilation.\n* **Object-Oriented:** Supports object-oriented programming principles (classes, objects, inheritance, polymorphism).\n\n**B. Data Types & Structures:**\n\n* **Numeric:** `int`, `float`, `complex` (e.g., `x = 10`, `y = 3.14`, `z = 2+3j`)\n* **String:** Sequence of characters (e.g., `name = \"Python\"`)\n* **Boolean:** `True` or `False`\n* **List:** Ordered, mutable sequence (e.g., `my_list = [1, 2, \"hello\"]`)\n* **Tuple:** Ordered, immutable sequence (e.g., `my_tuple = (1, 2, \"hello\")`)\n* **Set:** Unordered collection of unique elements (e.g., `my_set = {1, 2, 3}`)\n* **Dictionary:** Key-value pairs (e.g., `my_dict = {\"name\": \"Alice\", \"age\": 30}`)\n\n**C. Control Flow:**\n\n* **Conditional Statements:** `if`, `elif`, `else`\n* **Loops:** `for` (iterates over a sequence), `while` (repeats as long as a condition is true)\n* **Break & Continue:** `break` exits a loop, `continue` skips to the next iteration.\n\n**D. Functions:**\n\n* Reusable blocks of code. Defined using the `def` keyword.\n* Can accept arguments and return values.\n* Example:\n```python\ndef greet(name):\n  print(f\"Hello, {name}!\")\n\ngreet(\"Bob\")\n```\n\n**E. Object-Oriented Programming (OOP):**\n\n* **Classes:** Blueprints for creating objects.\n* **Objects:** Instances of a class.\n* **Methods:** Functions within a class.\n* **Attributes:** Variables within a class.\n* **Inheritance:** Creating new classes based on existing ones.\n* **Polymorphism:** Ability of objects of different classes to respond to the same method call in their own way.\n\n\n**F. Modules and Packages:**\n\n* **Modules:** Files containing Python code (.py).\n* **Packages:** Directories containing multiple modules.\n* Import modules using `import` (e.g., `import math`).\n\n\n**G. Exception Handling:**\n\n* Use `try...except` blocks to handle errors gracefully.\n* Example:\n```python\ntry:\n  result = 10 / 0\nexcept ZeroDivisionError:\n  print(\"Error: Division by zero\")\n```\n\n**H. File I/O:**\n\n* Open files using `open()` (e.g., `file = open(\"my_file.txt\", \"r\")`).\n* Read/write data using methods like `read()`, `write()`, `readline()`.\n* Remember to close files using `close()`.\n\n\n**III. Common Pitfalls & Debugging:**\n\n* **Indentation Errors:** Python uses indentation to define code blocks. Inconsistent indentation leads to errors.\n* **Name Errors:** Using undefined variables.\n* **Type Errors:** Performing operations on incompatible data types.\n* **Index Errors:** Accessing indices beyond the bounds of a sequence.\n* **Syntax Errors:** Incorrect code syntax.\n* **Use `print()` statements for debugging:** Insert `print()` statements strategically to check variable values and program flow.\n* **Use a debugger:**  Integrated Development Environments (IDEs) often have built-in debuggers.\n\n\n**IV. Practice Section:**\n\n1. **Write a function that takes a list of numbers and returns the sum of even numbers.**\n2. **Create a class representing a `Dog` with attributes like `name`, `breed`, and `age`.  Add a method to bark.**\n3. **Write a program that reads data from a file, counts the number of words, and prints the count.**\n4. **Write a program that handles potential `FileNotFoundError` exception when opening a file.**\n\n\n**Solutions (Brief):**\n\n1.  ```python\n    def sum_even(numbers):\n        return sum(num for num in numbers if num % 2 == 0)\n    ```\n2.  ```python\n    class Dog:\n        def __init__(self, name, breed, age):\n            self.name = name\n            self.breed = breed\n            self.age = age\n\n        def bark(self):\n            print(\"Woof!\")\n    ```\n3.  ```python\n    with open(\"my_file.txt\", \"r\") as file:\n        content = file.read()\n        words = content.split()\n        print(len(words))\n    ```\n4.  ```python\n    try:\n        with open(\"my_file.txt\", \"r\") as file:\n            # Process file\n            pass\n    except FileNotFoundError:\n        print(\"File not found\")\n    ```\n\nThis study guide provides a foundational understanding of Python.  Further exploration of specific topics and libraries is recommended for advanced proficiency.\n",
            "created_at": "2025-08-19T16:31:28.723483Z"
        },
        {
            "id": 1755621102184,
            "topic": "data structures",
            "content": "## Data Structures: A Comprehensive Study Note\n\n**I. Outline**\n\nA. Introduction to Data Structures\nB. Arrays\n    1. Definition and Characteristics\n    2. Operations\n    3. Advantages and Disadvantages\n    4. Example: Implementing a Stack using an Array\nC. Linked Lists\n    1. Definition and Types (Singly, Doubly, Circular)\n    2. Operations\n    3. Advantages and Disadvantages\n    4. Example: Implementing a Queue using a Linked List\nD. Stacks\n    1. Definition and Characteristics (LIFO)\n    2. Operations (Push, Pop, Peek)\n    3. Applications (Function calls, Undo/Redo)\n    4. Example: Implementing a Stack using a Linked List\nE. Queues\n    1. Definition and Characteristics (FIFO)\n    2. Operations (Enqueue, Dequeue)\n    3. Applications (Buffering, Task Scheduling)\n    4. Example: Implementing a Queue using an Array\nF. Trees\n    1. Definition and Types (Binary, Binary Search, AVL, Heap)\n    2. Traversal methods (Inorder, Preorder, Postorder)\n    3. Applications (Hierarchical data representation)\nG. Graphs\n    1. Definition and Types (Directed, Undirected, Weighted)\n    2. Representations (Adjacency Matrix, Adjacency List)\n    3. Applications (Social networks, Maps)\nH. Hash Tables\n    1. Definition and Collision Handling (Chaining, Probing)\n    2. Applications (Dictionaries, Symbol Tables)\n\n\n**II. Key Concepts & Concise Explanations**\n\n* **Data Structure:** A way of organizing and storing data in a computer so that it can be used efficiently.\n* **Abstract Data Type (ADT):** A high-level description of a data structure, specifying its operations but not its implementation.\n* **Algorithm:** A step-by-step procedure for solving a problem using a data structure.\n* **Time Complexity:** A measure of how the runtime of an algorithm scales with the input size (e.g., O(n), O(n log n), O(1)).\n* **Space Complexity:** A measure of how the memory usage of an algorithm scales with the input size.\n\n**III. Examples**\n\n* **Array:**  `int numbers[5] = {1, 2, 3, 4, 5};` (stores 5 integers contiguously in memory)\n* **Linked List (Singly):** Each node contains data and a pointer to the next node.  Useful for dynamic size data structures.\n* **Stack (using Array):**  `push(x)` adds `x` to the top, `pop()` removes and returns the top element.\n* **Queue (using Linked List):** `enqueue(x)` adds `x` to the rear, `dequeue()` removes and returns the front element.\n* **Binary Search Tree:** A tree where each node's left subtree contains smaller values and the right subtree contains larger values.  Efficient for search, insertion, and deletion.\n\n\n**IV. Common Pitfalls**\n\n* **ArrayIndexOutOfBoundsException:** Accessing an array element outside its bounds.\n* **Memory Leaks:** Failing to deallocate memory used by dynamically allocated data structures (like linked lists).\n* **Infinite Loops:**  Incorrectly implemented algorithms can lead to infinite loops, especially in recursive functions involving trees or graphs.\n* **Collision Handling in Hash Tables:**  Poor collision handling strategies can lead to performance degradation.\n* **Inaccurate Time Complexity Analysis:**  Overestimating or underestimating the time complexity of an algorithm can lead to inefficient solutions.\n\n\n**V. Advantages and Disadvantages of Common Data Structures**\n\n| Data Structure | Advantages                               | Disadvantages                                   |\n|-----------------|-------------------------------------------|-----------------------------------------------|\n| Array           | Fast access to elements using index       | Fixed size, insertion/deletion can be slow     |\n| Linked List     | Dynamic size, efficient insertion/deletion | Slower access to elements                      |\n| Stack           | LIFO access                               | Limited access to elements                     |\n| Queue           | FIFO access                               | Limited access to elements                     |\n| Tree            | Efficient search, insertion, deletion (BST) | Can become unbalanced, leading to slowdowns     |\n| Graph           | Represents relationships between data     | Can be complex to implement and traverse       |\n| Hash Table      | Fast average-case search, insertion, deletion | Worst-case performance can be O(n) due to collisions |\n\n\n\n**VI. Practice Section**\n\n1. **Implement a function to reverse a singly linked list.**\n2. **Write a function to check if a given binary tree is a binary search tree.**\n3. **Implement a stack using two queues.**\n4. **Describe a scenario where a graph data structure would be more appropriate than an array.**\n5. **Explain how to handle collisions in a hash table using separate chaining.**\n\n\nThis study note provides a foundational understanding of common data structures.  Further exploration of specific data structures and advanced algorithms is recommended for a deeper understanding.  Remember to practice implementing these structures and algorithms to solidify your knowledge.\n",
            "created_at": "2025-08-19T16:31:42.184292Z"
        },
        {
            "id": 1755621114949,
            "topic": "algorithms",
            "content": "## Study Note: Algorithms\n\n**I. Outline:**\n\nA. Introduction to Algorithms\nB. Key Concepts\n    1. Algorithm Properties\n    2. Algorithm Design Paradigms\nC. Common Algorithm Types\n    1. Searching Algorithms\n    2. Sorting Algorithms\n    3. Graph Algorithms\n    4. Dynamic Programming\nD. Algorithm Analysis (Big O Notation)\nE. Common Pitfalls\nF. Practice Problems\n\n\n**II. Key Concepts:**\n\n**A. Introduction to Algorithms:**  An algorithm is a step-by-step procedure or formula for solving a problem or accomplishing a task.  It's a finite sequence of well-defined, computer-implementable instructions, typically to transform input into output.\n\n**B. Key Concepts:**\n\n    1. **Algorithm Properties:**\n        * **Correctness:**  The algorithm produces the correct output for all valid inputs.\n        * **Finiteness:** The algorithm terminates after a finite number of steps.\n        * **Definiteness:** Each step is precisely defined; the actions to be carried out are rigorously and unambiguously specified for each case.\n        * **Input:** The algorithm receives zero or more inputs.\n        * **Output:** The algorithm produces one or more outputs.\n        * **Effectiveness:** Each step must be feasible; it must be something that can be done exactly and in a finite amount of time.\n\n    2. **Algorithm Design Paradigms:** These are general approaches or strategies used to design algorithms.  Some common paradigms include:\n        * **Divide and Conquer:**  Break a problem into smaller subproblems, solve them recursively, and combine the solutions. (e.g., Merge Sort)\n        * **Dynamic Programming:** Solve overlapping subproblems only once and store their solutions to avoid redundant computations. (e.g., Fibonacci sequence calculation)\n        * **Greedy Approach:**  Make locally optimal choices at each step, hoping to find a global optimum.  (e.g., Dijkstra's algorithm)\n        * **Backtracking:**  Explore all possible solutions systematically, undoing choices if they lead to a dead end. (e.g., N-Queens problem)\n        * **Branch and Bound:**  Explore a tree of possibilities, pruning branches that are guaranteed to not lead to a better solution than the current best.\n\n\n**III. Common Algorithm Types:**\n\n    1. **Searching Algorithms:**\n        * **Linear Search:**  Check each element sequentially.  O(n) time complexity.\n        * **Binary Search:**  Works on sorted data; repeatedly divides the search interval in half. O(log n) time complexity.\n\n    2. **Sorting Algorithms:**\n        * **Bubble Sort:**  Repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. O(n\u00b2) time complexity.\n        * **Merge Sort:** Divide and conquer approach. O(n log n) time complexity.\n        * **Quick Sort:**  Picks an element as a pivot and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. O(n log n) average case, O(n\u00b2) worst case.\n\n    3. **Graph Algorithms:**\n        * **Breadth-First Search (BFS):** Explores the graph level by level.\n        * **Depth-First Search (DFS):** Explores the graph as deeply as possible along each branch before backtracking.\n        * **Dijkstra's Algorithm:** Finds the shortest paths from a single source node to all other nodes in a graph with non-negative edge weights.\n\n    4. **Dynamic Programming:**  Often used for optimization problems with overlapping subproblems.\n\n\n**IV. Algorithm Analysis (Big O Notation):** Big O notation describes the upper bound of the time or space complexity of an algorithm as the input size grows.  It focuses on the dominant terms and ignores constant factors.  Common complexities include: O(1) \u2013 constant, O(log n) \u2013 logarithmic, O(n) \u2013 linear, O(n log n) \u2013 linearithmic, O(n\u00b2) \u2013 quadratic, O(2\u207f) \u2013 exponential.\n\n\n**V. Common Pitfalls:**\n\n* **Incorrect base cases in recursive algorithms.**\n* **Off-by-one errors in loops.**\n* **Infinite loops.**\n* **Not handling edge cases (e.g., empty input).**\n* **Inefficient algorithms chosen for the problem.**\n* **Ignoring memory usage (space complexity).**\n\n\n**VI. Practice Problems:**\n\n1. **Write a function to implement linear search.**\n2. **Write a function to implement binary search.**\n3. **Describe the difference between BFS and DFS.**\n4. **Analyze the time complexity of bubble sort.**\n5. **Explain the concept of dynamic programming with a simple example (e.g., calculating Fibonacci numbers).**\n\n\nThis study note provides a foundational understanding of algorithms.  Further exploration into specific algorithm types and advanced techniques is recommended for a deeper understanding.  Remember to practice implementing algorithms to solidify your knowledge.\n",
            "created_at": "2025-08-19T16:31:54.949689Z"
        },
        {
            "id": 1755621127061,
            "topic": "system design",
            "content": "## System Design Study Notes\n\n**I. Outline:**\n\nA. **Introduction:** What is System Design?\nB. **Fundamental Concepts:**\n    1. Scalability (Horizontal vs. Vertical)\n    2. Availability & Reliability\n    3. Consistency & Data Integrity\n    4. Performance & Latency\n    5. Security\nC. **Architectural Patterns:**\n    1. Microservices\n    2. Monolithic Architecture\n    3. Client-Server\n    4. Message Queues (e.g., RabbitMQ, Kafka)\n    5. Databases (SQL vs. NoSQL)\nD. **Design Process:**\n    1. Requirements Gathering\n    2. High-Level Design\n    3. Detailed Design\n    4. System Testing & Deployment\nE. **Common Pitfalls & Best Practices**\nF. **Practice Problems**\n\n\n**II. Key Concepts & Concise Explanations:**\n\n* **Scalability:** Ability to handle increasing workloads.  *Horizontal scaling*: adding more machines, *Vertical scaling*: increasing resources of existing machines.\n* **Availability:** Percentage of time a system is operational.  High availability requires redundancy and failover mechanisms.\n* **Reliability:**  Consistency and dependability of a system over time.\n* **Consistency:** Data remains accurate and consistent across the system at all times (e.g., ACID properties in databases).\n* **Performance:** Speed and efficiency of the system.  Measured by latency (response time) and throughput (requests per second).\n* **Security:** Protecting the system from unauthorized access, use, disclosure, disruption, modification, or destruction.\n\n\n**III. Architectural Patterns:**\n\n* **Microservices:** System composed of small, independent services.  Highly scalable and flexible but complex to manage.  *Example*: Netflix.\n* **Monolithic Architecture:** All components are tightly coupled in a single application. Simple to develop and deploy but difficult to scale and maintain.  *Example*: Older enterprise applications.\n* **Client-Server:** Client requests services from a server.  Common in web applications.\n* **Message Queues:** Used for asynchronous communication between services.  Decouples services and improves scalability. *Example*: Handling order processing in an e-commerce platform.\n* **Databases:**  Store and manage data.\n    * **SQL (Relational):** Structured data with predefined schemas.  *Example*: MySQL, PostgreSQL.\n    * **NoSQL (Non-relational):** Flexible schemas to handle unstructured or semi-structured data.  *Example*: MongoDB, Cassandra.\n\n\n**IV. Design Process:**\n\n1. **Requirements Gathering:** Understand the needs and constraints of the system.\n2. **High-Level Design:**  Identify core components, their interactions, and overall architecture.\n3. **Detailed Design:** Specify details of each component, including data models, algorithms, and APIs.\n4. **System Testing & Deployment:** Thorough testing to ensure system functionality and performance.\n\n\n**V. Common Pitfalls & Best Practices:**\n\n* **Ignoring scalability:**  Not planning for future growth.\n* **Over-engineering:** Building a system that is too complex for its needs.\n* **Lack of monitoring and logging:** Difficulty in troubleshooting and identifying performance bottlenecks.\n* **Insufficient testing:**  Releasing buggy software.\n* **Security vulnerabilities:** Inadequate security measures leading to breaches.\n\n\n**VI. Practice Problems:**\n\n**Problem 1:** Design a URL shortening service (like bit.ly). Consider scalability, data storage, and performance.  What database would you choose and why?\n\n**Problem 2:** Design a system for a ride-sharing application (like Uber).  Focus on aspects like real-time location tracking, driver/rider matching, and payment processing.  What architectural patterns would you consider?\n\n\n**VII.  Further Exploration:**\n\n* CAP Theorem\n* Consistent Hashing\n* Load Balancing\n* Caching Strategies\n\n\nThis study note provides a foundation for understanding system design.  Further research and practice are crucial to mastering this complex field. Remember to delve deeper into each topic and explore different design choices and their trade-offs.\n",
            "created_at": "2025-08-19T16:32:07.061059Z"
        }
    ],
    "exams": [
        {
            "id": 1755621094039,
            "topic": "python",
            "quiz": "**Python Quiz:**\n\n**Instructions:** Choose the best answer for each multiple-choice question.\n\n**1. What is the correct way to declare a variable named `x` and assign it the value 10 in Python?**\nA. `int x = 10;`\nB. `var x = 10;`\nC. `x = 10`\nD. `10 = x`\n**Correct Answer: C**\n\n\n**2. Which data type is used to represent True or False values in Python?**\nA. Integer\nB. Float\nC. String\nD. Boolean\n**Correct Answer: D**\n\n\n**3.  What is the output of the following code?**\n```python\nprint(type(5))\n```\nA. <class 'str'>\nB. <class 'int'>\nC. <class 'float'>\nD. <class 'bool'>\n**Correct Answer: B**\n\n\n**4. What does the `len()` function do?**\nA. Calculates the sum of the elements in a list.\nB. Returns the length (number of items) of a sequence (string, list, tuple, etc.).\nC. Prints the elements of a list.\nD.  Converts a number to a string.\n**Correct Answer: B**\n\n\n**5. What is the result of `2**3` in Python?**\nA. 5\nB. 6\nC. 8\nD. 9\n**Correct Answer: C**  (This is exponentiation: 2 raised to the power of 3)\n\n\n**6. Which loop is best suited for iterating a specific number of times?**\nA. `while` loop\nB. `for` loop with `range()`\nC. `if` statement\nD. `break` statement\n**Correct Answer: B**\n\n\n**7. Which statement is used to conditionally execute a block of code?**\nA. `loop`\nB. `function`\nC. `if`\nD. `print`\n**Correct Answer: C**\n\n\n**8.  What does the `append()` method do when used with a list?**\nA. Removes the last element from the list.\nB. Adds an element to the beginning of the list.\nC. Adds an element to the end of the list.\nD. Removes a specific element from the list.\n**Correct Answer: C**\n\n\n**9. What will be the output of this code snippet?**\n```python\nmy_list = [1, 2, 3, 4, 5]\nprint(my_list[2])\n```\nA. 1\nB. 2\nC. 3\nD. 5\n**Correct Answer: C**  (List indexing starts from 0)\n\n\n**10. A function in Python is defined using which keyword?**\nA. `class`\nB. `def`\nC. `for`\nD. `while`\n**Correct Answer: B**\n",
            "created_at": "2025-08-19T16:31:34.039436Z"
        },
        {
            "id": 1755621106423,
            "topic": "data structures",
            "quiz": "**Data Structures Quiz**\n\n**Instructions:** Choose the best answer for each multiple-choice question.\n\n**1. Which of the following is NOT a fundamental data structure?**\nA. Array\nB. Stack\nC. Graph\nD. Algorithm\n\n*Correct Answer: D*\n\n\n**2. A linear data structure that follows the LIFO (Last-In, First-Out) principle is called a:**\nA. Queue\nB. Stack\nC. Deque\nD. Tree\n\n*Correct Answer: B*\n\n\n**3.  Which data structure uses a key-value pair for storing data?**\nA. Array\nB. Linked List\nC. Hash Table\nD. Stack\n\n*Correct Answer: C*\n\n\n**4.  What is the time complexity of searching for an element in a sorted array using binary search?**\nA. O(n)\nB. O(log n)\nC. O(1)\nD. O(n^2)\n\n*Correct Answer: B*\n\n\n**5.  A linked list where each node points to the next node and the last node points to the first node is called a:**\nA. Singly Linked List\nB. Doubly Linked List\nC. Circular Linked List\nD. Skip List\n\n*Correct Answer: C*\n\n\n**6.  Which of the following data structures is best suited for implementing a breadth-first search (BFS) algorithm?**\nA. Stack\nB. Queue\nC. Heap\nD. Linked List\n\n*Correct Answer: B*\n\n\n**7.  A tree where each node has at most two children is called a:**\nA. Binary Tree\nB. Ternary Tree\nC. General Tree\nD. AVL Tree\n\n*Correct Answer: A*\n\n\n**8. A self-balancing binary search tree is known as:**\nA. Binary Search Tree\nB. Heap\nC. AVL Tree\nD. Graph\n\n*Correct Answer: C*\n\n\n**9. Which data structure is particularly efficient for finding the minimum or maximum element?**\nA. Queue\nB. Linked List\nC. Heap\nD. Stack\n\n*Correct Answer: C*\n\n\n**10.  A graph where all edges have the same weight is called a:**\nA. Weighted Graph\nB. Directed Graph\nC. Unweighted Graph\nD. Cyclic Graph\n\n*Correct Answer: C*\n",
            "created_at": "2025-08-19T16:31:46.423590Z"
        },
        {
            "id": 1755621119998,
            "topic": "algorithms",
            "quiz": "**Algorithms Quiz**\n\n**Instructions:** Choose the best answer for each multiple-choice question.\n\n**1. Which of the following best describes an algorithm?**\nA) A programming language\nB) A sequence of steps to solve a problem\nC) A computer program\nD) A type of data structure\n\n**Correct Answer: B**\n\n\n**2. What is the time complexity of linear search in the worst case?**\nA) O(1)\nB) O(log n)\nC) O(n)\nD) O(n log n)\n\n**Correct Answer: C**\n\n\n**3. Which sorting algorithm has the best average-case time complexity?**\nA) Bubble Sort\nB) Insertion Sort\nC) Merge Sort\nD) Selection Sort\n\n**Correct Answer: C**\n\n\n**4.  What does a recursive algorithm involve?**\nA) Iterating through a loop\nB) Calling itself\nC) Using a stack data structure\nD) All of the above\n\n**Correct Answer: B**\n\n\n**5. What data structure is commonly used in Breadth-First Search (BFS)?**\nA) Stack\nB) Queue\nC) Heap\nD) Tree\n\n**Correct Answer: B**\n\n\n**6.  Which algorithm is best suited for finding the shortest path in a graph with non-negative edge weights?**\nA) Dijkstra's Algorithm\nB) Bellman-Ford Algorithm\nC) Floyd-Warshall Algorithm\nD) Depth-First Search\n\n**Correct Answer: A**\n\n\n**7.  What is the purpose of a greedy algorithm?**\nA) To find the globally optimal solution\nB) To find a locally optimal solution at each step\nC) To explore all possible solutions\nD) To guarantee the best solution\n\n**Correct Answer: B**\n\n\n**8.  What is Big O notation used for?**\nA) Describing the memory usage of an algorithm\nB) Describing the time complexity of an algorithm\nC) Describing the programming language used\nD) Both A and B\n\n**Correct Answer: D**\n\n\n**9.  Which of the following is NOT a common way to represent a graph?**\nA) Adjacency Matrix\nB) Adjacency List\nC) Binary Tree\nD) Edge List\n\n**Correct Answer: C**\n\n\n**10.  What is the primary difference between Depth-First Search (DFS) and Breadth-First Search (BFS)?**\nA) DFS uses a stack, BFS uses a queue.\nB) DFS explores all neighbors of a node before moving to other nodes, BFS explores nodes level by level.\nC) DFS is used for trees, BFS is used for graphs.\nD) A and B\n\n**Correct Answer: D**\n",
            "created_at": "2025-08-19T16:31:59.998085Z"
        }
    ]
}